; ========== Data Declarations (Add to .data) ==========

nerf1_x         dw 0
nerf1_y         dw 0
nerf1_active    db 0   ; Ball Speed Up

nerf2_x         dw 0
nerf2_y         dw 0
nerf2_active    db 0   ; Paddle Shrink

nerf3_x         dw 0
nerf3_y         dw 0
nerf3_active    db 0   ; Life Deduction

; Power-up data
power1_x        dw 0
power1_y        dw 0
power1_active   db 0   ; Slow motion

power2_x        dw 0
power2_y        dw 0
power2_active   db 0   ; Bigger ball

power3_x        dw 0
power3_y        dw 0
power3_active   db 0   ; Score multiplier

score_multiplier db 1  ; 1 = normal, 2 = double
ball_size        db 1  ; 1 = normal, 2 = bigger


; ========== updateNerfs Procedure (Add to .code) ==========

updateNerfs proc
    push ax
    push bx
    push cx
    push dx

    ; ------------ NERF 1: SPEED UP --------------
    cmp nerf1_active, 1
    jne skip_nerf1
    inc nerf1_y

    mov ax, nerf1_y
    cmp ax, strikerY
    jne skip_nerf1

    mov ax, nerf1_x
    sub ax, strikerX
    cmp ax, wid
    jae skip_nerf1

    ; Collision with speed nerf
    inc fastball
    dec innerDelay
    mov nerf1_active, 0

skip_nerf1:

    ; ------------ NERF 2: PADDLE SHRINK --------------
    cmp nerf2_active, 1
    jne skip_nerf2
    inc nerf2_y

    mov ax, nerf2_y
    cmp ax, strikerY
    jne skip_nerf2

    mov ax, nerf2_x
    sub ax, strikerX
    cmp ax, wid
    jae skip_nerf2

    ; Collision with paddle shrink
    cmp wid, 10
    jbe skip_nerf2
    sub wid, 5
    mov nerf2_active, 0

skip_nerf2:

    ; ------------ NERF 3: LOSE LIFE --------------
    cmp nerf3_active, 1
    jne skip_nerf3
    inc nerf3_y

    mov ax, nerf3_y
    cmp ax, strikerY
    jne skip_nerf3

    mov ax, nerf3_x
    sub ax, strikerX
    cmp ax, wid
    jae skip_nerf3

    ; Collision with life nerf
    cmp lives, 1
    jbe skip_nerf3
    dec lives
    mov nerf3_active, 0

skip_nerf3:

    ; ------------ POWER-UP 1: SLOW MOTION --------------
    cmp power1_active, 1
    jne skip_power1
    inc power1_y

    mov ax, power1_y
    cmp ax, strikerY
    jne skip_power1

    mov ax, power1_x
    sub ax, strikerX
    cmp ax, wid
    jae skip_power1

    ; Collision: slow motion
    cmp innerDelay, 3
    jae skip_power1
    inc innerDelay
    mov power1_active, 0

skip_power1:

    ; ------------ POWER-UP 2: BIGGER BALL --------------
    cmp power2_active, 1
    jne skip_power2
    inc power2_y

    mov ax, power2_y
    cmp ax, strikerY
    jne skip_power2

    mov ax, power2_x
    sub ax, strikerX
    cmp ax, wid
    jae skip_power2

    ; Collision: bigger ball
    mov ball_size, 2
    mov power2_active, 0

skip_power2:

    ; ------------ POWER-UP 3: SCORE MULTIPLIER --------------
    cmp power3_active, 1
    jne skip_power3
    inc power3_y

    mov ax, power3_y
    cmp ax, strikerY
    jne skip_power3

    mov ax, power3_x
    sub ax, strikerX
    cmp ax, wid
    jae skip_power3

    ; Collision: score multiplier
    mov score_multiplier, 2
    mov power3_active, 0

skip_power3:

    pop dx
    pop cx
    pop bx
    pop ax
    ret
updateNerfs endp


; ========== Modified Level Routines (within levelmode proc) ==========

level3Game:
    call levelThree
    mov innerDelay, 1
    mov fastball, 1

    ; Nerf and power-ups initialized dynamically via game loop every 20s
    jmp next

level4Game:
    call levelFour
    mov innerDelay, 1
    mov fastball, 1

    ; Nerf and power-ups initialized dynamically via game loop every 20s
    jmp next

level5Game:
    call levelFive
    mov innerDelay, 2
    mov fastball, 2

    ; Nerf and power-ups initialized dynamically via game loop every 20s
    jmp next


; ========== Inside gameLoop (each frame) ==========

; (somewhere inside your main game loop logic)
call updateNerfs

    ; Every ~20 seconds (example logic)
    inc timeCtr
    cmp timeCtr, 2000     ; Adjust this value based on timer granularity
    jne skipPowerTrigger

    ; Reset time counter
    mov timeCtr, 0

    ; Randomize power-up (very basic pseudo-random logic)
    mov al, scoreCount
    and al, 03h
    cmp al, 0
    je spawnPower1
    cmp al, 1
    je spawnPower2
    cmp al, 2
    je spawnPower3
    jmp skipPowerTrigger

spawnPower1:
    mov ax, brick1x
    mov power1_x, ax
    mov ax, brick1y
    mov power1_y, ax
    mov power1_active, 1
    jmp skipPowerTrigger

spawnPower2:
    mov ax, brick2x
    mov power2_x, ax
    mov ax, brick2y
    mov power2_y, ax
    mov power2_active, 1
    jmp skipPowerTrigger

spawnPower3:
    mov ax, brick3x
    mov power3_x, ax
    mov ax, brick3y
    mov power3_y, ax
    mov power3_active, 1

skipPowerTrigger:
